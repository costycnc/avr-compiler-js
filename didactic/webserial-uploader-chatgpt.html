<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>ATmega328P WebSerial Uploader (128-byte pages)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, Arial, sans-serif; max-width: 800px; margin: 24px auto; padding: 0 12px; }
    h1 { font-size: 1.2rem; }
    button { padding: 8px 14px; margin-right: 8px; }
    #log { background: #111; color: #eee; padding: 12px; min-height: 180px; white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    input[type=file] { margin: 8px 0; }
    .row { margin: 10px 0; }
    .ok { color: #8cff8c; }
    .err { color: #ff8c8c; }
  </style>
</head>
<body>
  <h1>ATmega328P WebSerial Uploader (128-byte pages)</h1>

  <div class="row">
    <button id="btnConnect">Connect</button>
    <label>Baud:
      <input id="baud" type="number" value="115200" min="1200" step="100">
    </label>
  </div>

  <div class="row">
    <input id="hexFile" type="file" accept=".hex" />
    <button id="btnUpload" disabled>Upload HEX</button>
    <button id="btnReset" disabled>Reset</button>
  </div>

  <div id="log"></div>

  <script>
    // ---- Minimal STK500v1 constants (Optiboot subset)
    const Sync_CRC_EOP = 0x20;
    const Resp_STK_OK = 0x10;
    const Resp_STK_INSYNC = 0x14;

    const Cmnd_STK_GET_SYNC      = 0x30;
    const Cmnd_STK_ENTER_PROGMODE= 0x50;
    const Cmnd_STK_LEAVE_PROGMODE= 0x51;
    const Cmnd_STK_LOAD_ADDRESS  = 0x55; // address in WORDS (little endian)
    const Cmnd_STK_PROG_PAGE     = 0x64;

    // ---- UI helpers
    const logEl = document.getElementById('log');
    function log(msg, cls='') {
      const line = document.createElement('div');
      if (cls) line.className = cls;
      line.textContent = msg;
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }
    function hex(n, w=2) { return '0x' + n.toString(16).toUpperCase().padStart(w,'0'); }

    // ---- Serial globals
    let port, writer;
    let readQueue = [];

    async function connect() {
      try {
        port = await navigator.serial.requestPort();
        const baudRate = parseInt(document.getElementById('baud').value, 10) || 115200;
        await port.open({ baudRate });
        writer = port.writable.getWriter();
        startReadLoop(port.readable);
        log('✅ Connected at ' + baudRate, 'ok');

        // Toggle DTR to reset UNO
        await port.setSignals({ dataTerminalReady: false, requestToSend: false });
        await sleep(50);
        await port.setSignals({ dataTerminalReady: true, requestToSend: false });
        await sleep(50);
        await port.setSignals({ dataTerminalReady: false, requestToSend: false });
        log('↻ Toggled DTR to reset bootloader');

        document.getElementById('btnUpload').disabled = false;
        document.getElementById('btnReset').disabled = false;
      } catch (e) {
        log('Connect error: ' + e.message, 'err');
      }
    }

    async function resetOnly() {
      if (!port) return;
      await port.setSignals({ dataTerminalReady: false, requestToSend: false });
      await sleep(50);
      await port.setSignals({ dataTerminalReady: true, requestToSend: false });
      await sleep(50);
      await port.setSignals({ dataTerminalReady: false, requestToSend: false });
      log('↻ Reset pulse sent');
    }

    function startReadLoop(readable) {
      (async () => {
        const readerLocal = readable.getReader();
        try {
          while(true){
            const { value, done } = await readerLocal.read();
            if(done) break;
            if(value) readQueue.push(...value);
          }
        } catch {} finally { readerLocal.releaseLock(); }
      })();
    }

    async function writeBytes(bytes){ await writer.write(new Uint8Array(bytes)); }

    async function readN(n, timeoutMs=500){
      const start = performance.now();
      while(readQueue.length < n){
        if(performance.now() - start > timeoutMs) break;
        await sleep(2);
      }
      return readQueue.splice(0, Math.min(n, readQueue.length));
    }

    function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

    // ---- STK500 helpers
    async function stkCmd(cmdBytes, respLen=2, timeout=500){
      await writeBytes([...cmdBytes, Sync_CRC_EOP]);
      const resp = await readN(respLen, timeout);
      if(resp.length<respLen) throw new Error('Timeout waiting response');
      if(resp[0]!==Resp_STK_INSYNC || resp[resp.length-1]!==Resp_STK_OK){
        throw new Error('Bad response: [' + resp.map(b=>hex(b)).join(' ') + ']');
      }
      return resp;
    }

    async function stkGetSync(){ 
      for(let i=0;i<5;i++){ 
        try{ await stkCmd([Cmnd_STK_GET_SYNC]); log('STK_GET_SYNC → INSYNC/OK','ok'); return true; } 
        catch{ await sleep(60); } 
      } 
      throw new Error('Unable to get SYNC'); 
    }
    async function stkEnterProg(){ await stkCmd([Cmnd_STK_ENTER_PROGMODE]); log('Entered programming mode','ok'); }
    async function stkLeaveProg(){ await stkCmd([Cmnd_STK_LEAVE_PROGMODE]); log('Left programming mode','ok'); }
    async function stkLoadAddress(wordAddress){ 
      const low = wordAddress & 0xFF, high = (wordAddress>>8)&0xFF;
      await stkCmd([Cmnd_STK_LOAD_ADDRESS, low, high]);
    }
    async function stkProgPage(bytes){
      const len = bytes.length;
      const lenHi = (len>>8)&0xFF, lenLo=len&0xFF;
      await writeBytes([Cmnd_STK_PROG_PAGE, lenHi,lenLo,'F'.charCodeAt(0)]);
      await writeBytes(bytes);
      await writeBytes([Sync_CRC_EOP]);
      const resp = await readN(2,1000);
      if(!resp.includes(Resp_STK_INSYNC)||!resp.includes(Resp_STK_OK)){
        throw new Error('PROG_PAGE failed, resp=' + resp.map(b=>hex(b)).join(' '));
      }
    }

    // ---- Intel HEX parser to Uint8Array (sparse fill with 0xFF)
    function parseIntelHex(text, pageSize=128){
      const mem = new Map();
      let upper=0, maxAddr=0;
      const lines = text.split(/\r?\n/).filter(Boolean);
      for(const line of lines){
        if(line[0]!==':') throw new Error('Invalid HEX line');
        const bytes=[];
        for(let i=1;i<line.length;i+=2) bytes.push(parseInt(line.substr(i,2),16));
        const len=bytes[0], addr=(bytes[1]<<8)|bytes[2], type=bytes[3], data=bytes.slice(4,4+len);
        if(type===0x00){ const base=(upper<<16)|addr; for(let i=0;i<data.length;i++){ const a=base+i; mem.set(a,data[i]); if(a>maxAddr) maxAddr=a; } }
        else if(type===0x04){ upper=(data[0]<<8)|data[1]; }
        else if(type===0x01){ break; }
      }
      const out=new Uint8Array(maxAddr+1).fill(0xFF);
      for(const [addr,val] of mem.entries()) out[addr]=val;
      const padded=Math.ceil(out.length/pageSize)*pageSize;
      if(padded!==out.length){ const tmp=new Uint8Array(padded).fill(0xFF); tmp.set(out); return tmp; }
      return out;
    }

    async function uploadHex(){
      try{
        const f=document.getElementById('hexFile').files[0];
        if(!f){ alert('Choose an Intel HEX file first'); return; }
        const txt = await f.text();
        const pageSize=128;
        const image=parseIntelHex(txt,pageSize);
        log(`HEX parsed: ${image.length} bytes (padded to ${pageSize}B pages)`);

        await resetOnly(); await sleep(100);
        await stkGetSync(); await stkEnterProg();

        for(let offset=0; offset<image.length; offset+=pageSize){
          const chunk=image.slice(offset, offset+pageSize);
          const wordAddress=offset>>>1;
          await stkLoadAddress(wordAddress);
          await stkProgPage(chunk);
          log(`Wrote page @ ${hex(offset,4)} (${chunk.length}B)`);
          await sleep(5);
        }

        await stkLeaveProg();
        log('✅ Upload complete','ok');
      } catch(e){ log('❌ Upload error: '+e.message,'err'); }
    }

    // ---- UI
    document.getElementById('btnConnect').addEventListener('click',connect);
    document.getElementById('btnUpload').addEventListener('click',uploadHex);
    document.getElementById('btnReset').addEventListener('click',resetOnly);
  </script>
</body>
</html>
